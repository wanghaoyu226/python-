import socket
import threading
import tkinter as tk
from tkinter import scrolledtext, messagebox
import json

class ChatApp:
    def __init__(self, root):
        self.root = root
        self.root.title("简易聊天客户端")
        self.root.geometry("600x500")

        # 网络连接
        self.sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        try:
            self.sock.connect(('localhost', 8889))
        except Exception as e:
            messagebox.showerror("错误", f"无法连接服务器: {e}")
            root.destroy()
            return

        # 状态变量
        self.logged_in = False
        self.username = ""
        self.login_win = None  # 登录窗口对象

        # 创建界面
        self.create_widgets()

        # 启动接收线程
        self.recv_thread = threading.Thread(target=self.recv_msg)
        self.recv_thread.daemon = True
        self.recv_thread.start()

        # 显示登录窗口
        self.show_login()

    def create_widgets(self):
        # 聊天记录
        self.chat_box = scrolledtext.ScrolledText(
            self.root, wrap=tk.WORD, state=tk.DISABLED
        )
        self.chat_box.pack(fill=tk.BOTH, expand=True, padx=10, pady=10)

        # 消息输入 + 发送
        bottom_frame = tk.Frame(self.root)
        bottom_frame.pack(fill=tk.X, padx=10, pady=10)

        self.msg_entry = tk.Entry(bottom_frame, width=40)
        self.msg_entry.pack(side=tk.LEFT, fill=tk.X, expand=True)
        self.msg_entry.bind("<Return>", self.send_msg)

        self.send_btn = tk.Button(bottom_frame, text="发送", command=self.send_msg)
        self.send_btn.pack(side=tk.RIGHT, padx=5)

        # 在线用户标签
        self.online_label = tk.Label(
            self.root, text="在线用户: 未登录", anchor=tk.W, padx=10, pady=5
        )
        self.online_label.pack(fill=tk.X)

    def show_login(self):
        """弹出登录窗口"""
        self.login_win = tk.Toplevel(self.root)
        self.login_win.title("用户登录")
        self.login_win.geometry("300x150")
        self.login_win.transient(self.root)
        self.login_win.grab_set()  # 锁定主窗口

        # 用户名
        tk.Label(self.login_win, text="用户名:").grid(
            row=0, column=0, padx=10, pady=10, sticky=tk.E
        )
        self.login_user = tk.Entry(self.login_win)
        self.login_user.grid(row=0, column=1, padx=10, pady=10, sticky=tk.W)

        # 密码
        tk.Label(self.login_win, text="密码:").grid(
            row=1, column=0, padx=10, pady=10, sticky=tk.E
        )
        self.login_pwd = tk.Entry(self.login_win, show="*")
        self.login_pwd.grid(row=1, column=1, padx=10, pady=10, sticky=tk.W)

        # 登录按钮
        login_btn = tk.Button(
            self.login_win, text="登录", command=self.login
        )
        login_btn.grid(row=2, column=0, columnspan=2, pady=10)

    def login(self):
        """处理登录逻辑"""
        username = self.login_user.get()
        password = self.login_pwd.get()
        if not username or not password:
            messagebox.showerror("错误", "用户名/密码不能为空")
            return

        # 构造登录请求
        login_req = json.dumps({
            "type": "login",
            "username": username,
            "password": password
        })
        try:
            self.sock.send(login_req.encode('utf-8'))
        except Exception as e:
            messagebox.showerror("错误", f"发送失败: {e}")
            self.login_win.destroy()
            return

        # 禁用登录窗口防止重复提交
        for widget in self.login_win.winfo_children():
            widget.config(state=tk.DISABLED)

    def recv_msg(self):
        """持续接收服务器消息"""
        while True:
            try:
                data = self.sock.recv(1024).decode('utf-8')
                if not data:
                    break
                msg = json.loads(data)
                self.handle_msg(msg)
            except json.JSONDecodeError:
                self.append_chat(f"[错误] 无效消息格式: {data}")
            except Exception as e:
                self.append_chat(f"[错误] 连接丢失: {e}")
                break

    def handle_msg(self, msg):
        """根据消息类型处理"""
        msg_type = msg.get("type")
        if msg_type == "login_success":
            # 登录成功
            self.logged_in = True
            self.username = self.login_user.get()
            self.root.title(f"聊天客户端 - {self.username}")
            # 关闭登录窗口
            if self.login_win:
                self.login_win.destroy()
                self.login_win = None
            # 更新在线用户
            self.update_online(msg.get("online_users", []))
            # 提示
            self.append_chat(f"系统: {msg.get('msg', '登录成功')}")

        elif msg_type == "login_fail":
            # 登录失败
            messagebox.showerror("登录失败", msg.get("msg", "未知错误"))
            # 恢复登录窗口
            if self.login_win:
                for widget in self.login_win.winfo_children():
                    widget.config(state=tk.NORMAL)

        elif msg_type == "chat":
            # 聊天消息，提取 content 字段展示
            sender = msg.get("sender", "匿名")
            content = msg.get("content", "无内容")
            # 直接展示 content 里的实际聊天内容，而不是整个消息字典
            self.append_chat(f"{sender}: {content}")  

        elif msg_type == "online_update":
            # 在线用户更新
            self.update_online(msg.get("online_users", []))

        else:
            # 未知类型
            self.append_chat(f"[未知类型] {msg}")

    def update_online(self, users):
        """更新在线用户显示"""
        if users:
            self.online_label.config(text=f"在线用户: {', '.join(users)}")
        else:
            self.online_label.config(text="在线用户: 无")

    def append_chat(self, text):
        """线程安全地追加聊天内容"""
        self.root.after(0, lambda: self._safe_append(text))

    def _safe_append(self, text):
        """实际更新聊天框"""
        self.chat_box.config(state=tk.NORMAL)
        self.chat_box.insert(tk.END, text + "\n")
        self.chat_box.see(tk.END)
        self.chat_box.config(state=tk.DISABLED)

    def send_msg(self, event=None):
        """发送聊天消息"""
        if not self.logged_in:
            messagebox.showwarning("提示", "请先登录")
            return
        msg = self.msg_entry.get().strip()
        if not msg:
            return
        # 构造聊天消息
        chat_msg = json.dumps({
            "type": "chat",
            "sender": self.username,
            "content": msg
        })
        try:
            self.sock.send(chat_msg.encode('utf-8'))
            self.msg_entry.delete(0, tk.END)
            # 自己的消息也显示
            self.append_chat(f"你: {msg}")
        except Exception as e:
            messagebox.showerror("错误", f"发送失败: {e}")

if __name__ == "__main__":
    root = tk.Tk()
    app = ChatApp(root)
    root.mainloop()
